<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Netty5+Spring+Maven简易框架环境搭建]]></title>
    <url>%2F2017%2F11%2F29%2FNetty5-Spring-Maven%E7%AE%80%E6%98%93%E6%A1%86%E6%9E%B6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[文章结构说明 Maven引入 Netty5简易使用 Netty5的Spring封装 Spring配置 程序打包、运行 Netty5+Maven+Spring环境搭建环境说明 IDEA jdk1.7+ maven3 Maven引入在IDEA中新建maven项目 可以用模板导入也可以不用 如下没有模板导入 File –&gt; New –&gt; Project. 如图 选择maven，选择jdk1.8 –&gt; Next 填好maven三坐标 –&gt; Next 填好项目信息 –&gt; Finish 等项目自动创建成功，项目如图pom文件现在还是空的 笔者的习惯会补全项目的文件，如图 以上我们建立了一个空的maven项目，由于netty是一个非web应用，所有没有webapp的结构 在maven的pom文件中引入我们需要的依赖 如下123456789101112131415161718192021&lt;dependencies&gt; &lt;!-- netty5 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;5.0.0.Alpha2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring的包，其它的包都会通过依赖间接的引入 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 方便测试的Junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Netty5先看一个Netty5的简单例子 Server启动类 1234567891011121314151617181920212223242526272829303132333435363738394041public class EchoServer &#123; private int port; public EchoServer(int port) &#123; this.port = port; &#125; public void run() throws Exception &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap();// Server启动类 b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class)// 通道类型 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new EchoServerHandler()); &#125; &#125;)// Server的处理类通常是chiledHandler， // 需要添加一个channel处理类的工厂方法ChannelInitializer， //通过覆盖initChannel方法，增添处理类 .option(ChannelOption.SO_BACKLOG, 128) .childOption(ChannelOption.SO_KEEPALIVE, true); ChannelFuture f = b.bind(port).sync(); //让主线程阻塞 f.channel().closeFuture().sync();// 主线程退出时异步关闭通道操作 &#125; finally &#123; workerGroup.shutdownGracefully();// 一定要加上 bossGroup.shutdownGracefully(); &#125; &#125; public static void main(String[] args) throws Exception &#123; int port; if (args.length &gt; 0) &#123; port = Integer.parseInt(args[0]); &#125; else &#123; port = 8080; &#125; new EchoServer(port).run(); &#125;&#125; Server数据处理Handler 12345678910111213141516public class EchoServerHandler extends ChannelHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; ctx.write(msg); &#125; @Override public void channelReadComplete(ChannelHandlerContext ctx) &#123; ctx.flush(); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; // (4) // Close the connection when an exception is raised. cause.printStackTrace(); ctx.close(); &#125;&#125; 启动测试 运行Server类的main方法 终端输入命令 telnet localhost 8080 任何输入Server都会原样返回如图 Netty面向Spring封装为了将上述的过程通过Spring管理，需要对NettyServer做两件事 将NettyServer的配置POJO化，以方便Spring的Bean组装和管理 将NettyServer的管理面向接口，以方便Spring的接入以下是具体的实现过程 类关系图 Server、NettyServer是服务器的接口 AbstractNettyServer是服务器的抽象类，封装部分通用实现 NettyTcpServer是基于Tcp协议的具体实现类 NettyConfig是面向Spring封装的Server配置类 通过ServerManager实现对Server生命周期的管理 MyChannelInitializer是类似数据流处理Handler类工厂，在这里添加(多个)数据流处理Handler。 EchoHandler是数据流处理的具体实现类，Server的具体业务逻辑在这里实现。 Entrance是程序的启动入口 每个类的具体实现 NettyConfig class 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class NettyConfig &#123; private NioEventLoopGroup bossGroup; private NioEventLoopGroup workerGroup; private int bossCount; private int workerCount; private int port = 12345; public NioEventLoopGroup getBossGroup() &#123; if (null == bossGroup) &#123; if (0 &gt;= bossCount) &#123; bossGroup = new NioEventLoopGroup(); &#125; else &#123; bossGroup = new NioEventLoopGroup(bossCount); &#125; &#125; return bossGroup; &#125; public void setBossGroup(NioEventLoopGroup bossGroup) &#123; this.bossGroup = bossGroup; &#125; public synchronized NioEventLoopGroup getWorkerGroup() &#123; if (null == workerGroup) &#123; if (0 &gt;= workerCount) &#123; workerGroup = new NioEventLoopGroup(); &#125; else &#123; workerGroup = new NioEventLoopGroup(workerCount); &#125; &#125; return workerGroup; &#125; public void setWorkerGroup(NioEventLoopGroup workerGroup) &#123; this.workerGroup = workerGroup; &#125; public int getBossCount() &#123; return bossCount; &#125; public void setBossCount(int bossCount) &#123; this.bossCount = bossCount; &#125; public int getWorkerCount() &#123; return workerCount; &#125; public void setWorkerCount(int workerCount) &#123; this.workerCount = workerCount; &#125; public int getPort() &#123; return port; &#125; public void setPort(int port) &#123; this.port = port; &#125;&#125; Server interface 12345public interface Server &#123; void start() throws Exception; void start(int port) throws Exception; void stop() throws Exception;&#125; NettyServer interface 12345public interface NettyServer extends Server &#123; ChannelInitializer&lt;? extends Channel&gt; getChannelInitializer(); void setChannelInitializer(ChannelInitializer&lt;? extends Channel&gt; initializer); NettyConfig getNettyConfig();&#125; AbstractNettyServer abstract class 123456789101112131415161718192021222324252627282930313233343536373839404142434445public abstract class AbstractNettyServer implements NettyServer &#123; protected final NettyConfig nettyConfig; protected ChannelInitializer&lt;? extends Channel&gt; channelInitializer; public static final ChannelGroup ALL_CHANNELS = new DefaultChannelGroup("NADRON-CHANNELS", GlobalEventExecutor.INSTANCE); public AbstractNettyServer(NettyConfig nettyConfig, ChannelInitializer&lt;? extends Channel&gt; channelInitializer) &#123; this.nettyConfig = nettyConfig; this.channelInitializer = channelInitializer; &#125; @Override public void start(int port) throws Exception &#123; nettyConfig.setPort(port); start(); &#125; @Override public void stop() throws Exception &#123; ChannelGroupFuture futures = ALL_CHANNELS.close(); try &#123; futures.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != nettyConfig.getBossGroup()) &#123; nettyConfig.getBossGroup().shutdownGracefully(); &#125; if (null != nettyConfig.getWorkerGroup()) &#123; nettyConfig.getWorkerGroup().shutdownGracefully(); &#125; &#125; &#125; @Override public ChannelInitializer&lt;? extends Channel&gt; getChannelInitializer() &#123; return channelInitializer; &#125; @Override public NettyConfig getNettyConfig() &#123; return nettyConfig; &#125; protected EventLoopGroup getBossGroup() &#123; return nettyConfig.getBossGroup(); &#125; protected EventLoopGroup getWorkerGroup() &#123; return nettyConfig.getWorkerGroup(); &#125;&#125; NettyServer class 12345678910111213141516171819202122232425262728public class NettyTcpServer extends AbstractNettyServer &#123; private ServerBootstrap b; public NettyTcpServer(NettyConfig nettyConfig, ChannelInitializer&lt;? extends Channel&gt; channelInitializer) &#123; super(nettyConfig, channelInitializer); &#125; @Override public void start() throws Exception &#123; try &#123; b = new ServerBootstrap(); b.group(getBossGroup(), getWorkerGroup()) .channel(NioServerSocketChannel.class) .childHandler(getChannelInitializer()) .option(ChannelOption.SO_BACKLOG, 128) .childOption(ChannelOption.SO_KEEPALIVE, true); ChannelFuture f = b.bind(nettyConfig.getPort()).sync(); ALL_CHANNELS.add(f.channel()); f.channel().closeFuture().sync(); &#125; finally &#123; stop(); &#125; &#125; @Override public void setChannelInitializer(ChannelInitializer&lt;? extends Channel&gt; initializer) &#123; this.channelInitializer = initializer; b.childHandler(initializer); &#125;&#125; MyChannelInitializer class 123456public class MyChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast("echoHandler", new EchoHandler()); &#125;&#125; EchoHandler class 12345678910111213141516public class EchoHandler extends ChannelHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; ctx.write(msg); &#125; @Override public void channelReadComplete(ChannelHandlerContext ctx) &#123; ctx.flush(); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; // (4) // Close the connection when an exception is raised. cause.printStackTrace(); ctx.close(); &#125;&#125; Spring接管配置工作 笔者采用xml配置的方式，利于代码与配置的分离，也可以用配置类的方式 配置xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="com.nettyspring"/&gt; &lt;bean id="tcpServer" class="com.nettyspring.first.example.server.NettyTcpServer" destroy-method="stop"&gt; &lt;constructor-arg ref="tcpConfig"/&gt; &lt;constructor-arg ref="myChannelInitializer"/&gt; &lt;/bean&gt; &lt;bean id="myChannelInitializer" class="com.nettyspring.first.example.Initializer.MyChannelInitializer"&gt;&lt;/bean&gt; &lt;bean id="tcpConfig" class="com.nettyspring.first.example.NettyConfig"&gt; &lt;property name="bossGroup" ref="bossGroup"/&gt; &lt;property name="workerGroup" ref="workerGroup"/&gt; &lt;property name="port" value="10086"/&gt; &lt;/bean&gt; &lt;bean id="bossGroup" class="io.netty.channel.nio.NioEventLoopGroup" destroy-method="shutdownGracefully"&gt; &lt;constructor-arg type="int" index="0" value="2"/&gt; &lt;/bean&gt; &lt;bean id="workerGroup" class="io.netty.channel.nio.NioEventLoopGroup" destroy-method="shutdownGracefully"&gt; &lt;constructor-arg type="int" index="0" value="8"/&gt; &lt;/bean&gt;&lt;/beans&gt; AppContext class 实现自己的AppContext，并在启动Server时调用，让Spring接管bean管理工作，由于上面配置了component-scan，支持Spring注解的使用 12345678910111213141516public class AppContext implements ApplicationContextAware &#123; public static ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; AppContext.applicationContext = applicationContext; &#125; public static Object fetchBean(String name) &#123; if (null == name) &#123; return null; &#125; if (null == applicationContext) &#123; applicationContext = new ClassPathXmlApplicationContext("classpath:applicationContext.xml"); &#125; return applicationContext.getBean(name); &#125;&#125; ServerManager class 123456789101112131415public class ServerManager &#123; private AbstractNettyServer nettyServer; public ServerManager() &#123; nettyServer = (AbstractNettyServer) AppContext.fetchBean("tcpServer"); &#125; public void startServer(int port) throws Exception &#123; nettyServer.start(port); &#125; public void startServer() throws Exception &#123; nettyServer.start(); &#125; public void stopServer() throws Exception &#123; nettyServer.stop(); &#125;&#125; Entrance class 123456789101112public class Entrance &#123; public static void main(String... args) &#123; ServerManager manager = new ServerManager(); try &#123; manager.startServer(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 打包、运行 打包需要的maven插件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;build&gt; &lt;finalName&gt;nettyFirst&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer"&gt; &lt;resource&gt;META-INF/spring.handlers&lt;/resource&gt; &lt;/transformer&gt; &lt;transformer implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer"&gt; &lt;resource&gt;META-INF/spring.schemas&lt;/resource&gt; &lt;/transformer&gt; &lt;transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"&gt; &lt;mainClass&gt;com.nettyspring.first.example.app.Entrance&lt;/mainClass&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; shade 插件可以指定jar文件执行的入口类，&lt;mainClass&gt;需自己指定上面的两个transformer的作用是将spring依赖包里的xml文件也打进去，如果没指定的话会出现schemas找不到的情况 打包、执行 maven clean install 会在工程目录下生成 target 目录，里面有生成的jar文件 。 java -jar XXX.jar 在终端输入 telnet localhost 10086 10086 为spring的配置xml里配置的端口号，如图 Netty5参考资料文档Netty5官方用户手册Netty5官方用户手册中文翻译 Netty5 示例程序通过maven引入12345&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-example&lt;/artifactId&gt; &lt;version&gt;5.0.0.Alpha2&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>netty</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uml类图]]></title>
    <url>%2F2017%2F09%2F06%2FUml%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[UML类图知识图谱 UML类图总结UML常用软件 starUML使用文档]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>Uml</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[健身计划]]></title>
    <url>%2F2017%2F09%2F06%2F%E5%81%A5%E8%BA%AB%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[健身计划 2017-09 – 2017-12]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>计划</tag>
        <tag>健身</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础知识体系总结]]></title>
    <url>%2F2017%2F07%2F06%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[基础知识体系 本科北邮 通信 研究生 北邮 信息与通信工程]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动实现分页]]></title>
    <url>%2F2017%2F07%2F05%2F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[简单分页功能实现一次取出所有的数据，适用于数据量较少的情景 数据表 table123456789101112131415161718192021222324&lt;table id="sample-table-1"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;问题编号&lt;/th&gt; &lt;th&gt;问题说明&lt;/th&gt; &lt;th&gt;问题类型&lt;/th&gt; &lt;th&gt;所属主题&lt;/th&gt; &lt;th&gt;UPDATOR&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 底部页数 有一个页数选择器 bootstrap 样式1234567891011121314151617181920212223242526272829&lt;div class="row" id="pager"&gt; &lt;div class="col-sm-5 col-sm-offset-1"&gt; &lt;label for="pageColumnNumber"&gt;共&amp;nbsp;$&#123;fn:length(questions)&#125;&amp;nbsp;条,&amp;nbsp;每页显示 &lt;select class="select-small" id="pageColumnNumber" onchange="changePageColumnNumber()"&gt; &lt;option value="10"&gt;10&lt;/option&gt; &lt;option value="20"&gt;20&lt;/option&gt; &lt;option value="50"&gt;50&lt;/option&gt; &lt;option value="100"&gt;100&lt;/option&gt; &lt;/select&gt; 行 &amp;nbsp;&amp;nbsp;&amp;nbsp;共 &amp;nbsp;&lt;label id="totalPage"&gt;&lt;/label&gt;&amp;nbsp;页 &lt;/label&gt; &lt;/div&gt; &lt;div class="col-sm-6"&gt; &lt;nav aria-label="Page navigation"&gt; &lt;ul class="pagination" id="pagenationUL"&gt; &lt;li onclick="arrowPager(1)"&gt;&lt;a href='####'&gt;&amp;laquo;&lt;/a&gt;&lt;/li&gt; &lt;li onclick="toPage(1)"&gt;&lt;a href='####'&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li onclick="toPage(2)"&gt;&lt;a href='####'&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li onclick="toPage(3)"&gt;&lt;a href='####'&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li onclick="toPage(4)"&gt;&lt;a href='####'&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li onclick="toPage(5)"&gt;&lt;a href='####'&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li onclick="arrowPager(0)"&gt;&lt;a href='####'&gt;&amp;raquo;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt;&lt;/div&gt; js 功能实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;script type="text/javascript"&gt; var pageColumnNumber = 10; var currentPage = 1; var begin = 0; var currentPageColumn = 0; var totalColumnNumber = 0; var totalPage = 0; jQuery(function ($) &#123; initPageTable(); &#125;); function arrowPager(flag) &#123; if (flag == 1) &#123; if (currentPage == 1) return; currentPage = currentPage - 1; &#125; else &#123; if (currentPage == totalPage) return; currentPage = currentPage + 1; &#125; begin = (currentPage - 1) * pageColumnNumber + 1; currentPageColumn = currentPage * pageColumnNumber &gt; totalColumnNumber ? (totalColumnNumber - begin + 1 ) : pageColumnNumber; showTable(); showPager(); &#125; function toPage(i) &#123; var nextPage = parseInt($("#pagenationUL li:eq(" + i + ") a").text()); if (isNaN(nextPage)) &#123; return; &#125; currentPage = nextPage; begin = (currentPage - 1) * pageColumnNumber + 1; currentPageColumn = currentPage * pageColumnNumber &gt; totalColumnNumber ? (totalColumnNumber - begin + 1 ) : pageColumnNumber; showTable(); showPager(); &#125; function showPager() &#123; $("#pagenationUL li").removeClass("active"); $("#pagenationUL li").removeClass("disabled"); $("#pagenationUL li").show(); if (totalPage &lt; 6 || currentPage &lt; 4) &#123; initPager(1); $("#pagenationUL li:gt(" + totalPage + ")").hide(); $("#pagenationUL li:eq(6)").show(); $cur = $("#pagenationUL li:eq(" + currentPage + ")"); $cur.addClass("active"); $cur.html("&lt;span&gt;" + currentPage + "&lt;/span&gt;"); &#125; else if (currentPage &lt; (totalPage - 1)) &#123; initPager(currentPage - 2); $cur = $("#pagenationUL li:eq(3)"); $cur.addClass("active"); $cur.html("&lt;span&gt;" + currentPage + "&lt;/span&gt;"); &#125; else if (currentPage == (totalPage - 1)) &#123; initPager(currentPage - 3); $cur = $("#pagenationUL li:eq(4)"); $cur.addClass("active"); $cur.html("&lt;span&gt;" + currentPage + "&lt;/span&gt;"); &#125; else &#123; initPager(currentPage - 4); $cur = $("#pagenationUL li:eq(5)"); $cur.addClass("active"); $cur.html("&lt;span&gt;" + currentPage + "&lt;/span&gt;"); &#125; if (currentPage == 1) &#123; $("#pagenationUL li:eq(0)").addClass("disabled"); $("#pagenationUL li:eq(0)").html("&lt;span&gt;&amp;laquo;&lt;/span&gt;"); &#125; if (currentPage == totalPage) &#123; $("#pagenationUL li:eq(6)").addClass("disabled"); $("#pagenationUL li:eq(6)").html("&lt;span&gt;&amp;raquo;&lt;/span&gt;"); &#125; &#125; function initPager(start) &#123; $("#pagenationUL li:eq(0)").html("&lt;a href='####'&gt;&amp;laquo;&lt;/a&gt;"); $("#pagenationUL li:eq(1)").html("&lt;a href='####'&gt;" + start + "&lt;/a&gt;"); $("#pagenationUL li:eq(2)").html("&lt;a href='####'&gt;" + (start + 1) + "&lt;/a&gt;"); $("#pagenationUL li:eq(3)").html("&lt;a href='####'&gt;" + (start + 2) + "&lt;/a&gt;"); $("#pagenationUL li:eq(4)").html("&lt;a href='####'&gt;" + (start + 3) + "&lt;/a&gt;"); $("#pagenationUL li:eq(5)").html("&lt;a href='####'&gt;" + (start + 4) + "&lt;/a&gt;"); $("#pagenationUL li:eq(6)").html("&lt;a href='####'&gt;&amp;raquo;&lt;/a&gt;"); &#125; function initPageTable() &#123; currentPage = 1; pageColumnNumber = $("#pageColumnNumber").val(); begin = (currentPage - 1) * pageColumnNumber + 1; totalColumnNumber = $("#sample-table-1").find("tr").length - 1; totalPage = Math.ceil(totalColumnNumber / pageColumnNumber); currentPageColumn = currentPage * pageColumnNumber &gt; totalColumnNumber ? (totalColumnNumber - begin + 1 ) : pageColumnNumber; showTable(); $("#totalPage").text(totalPage); showPager(); &#125; function changePageColumnNumber() &#123; pageColumnNumber = $("#pageColumnNumber").val(); initPageTable(); &#125; function showTable() &#123; $("#sample-table-1 tr:gt(0)").hide(); $("#sample-table-1 tr:gt(" + (begin - 1) + ")").filter(":lt(" + currentPageColumn + ")").show(); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>htmml</tag>
        <tag>javascript</tag>
        <tag>分页</tag>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java进阶架构师]]></title>
    <url>%2F2017%2F07%2F04%2Fjava%E8%BF%9B%E9%98%B6%E6%9E%B6%E6%9E%84%E5%B8%88%2F</url>
    <content type="text"><![CDATA[JAVA 架构师、技术专家职位要求数据平台部架构师 （阿里） Java基础扎实，熟练掌握IO、多线程、集合等基础类库 熟悉分布式缓存、消息机制、搜索引擎等技术 熟悉J2EE规范 掌握常用的设计模式 熟悉高并发、高性能的分布式系统的设计及应用、调优 熟悉SQL、了解Mysql及相关分布式存储技术 有团队管理和项目管理的经验 有大数据平台研发或者开发经验 有互联网相关经历，有ERP、BOSS系统，大型企业及大型系统设计和架构能力 JAVA 技术专家（阿里）一 linux平台上的java语言编程 熟悉数据库开发技术 熟悉shell编程 熟悉网络编程、多线程编程技术、大规模系统开发和设计经验 对数据结构、算法设计、系统架构设计有较深刻的理解 对大规模数据存储、传输、处理有丰富的经验 精通算法和建模 二 熟悉J2EE设计模式、精通JAVA及web应用的开发 深入了解Spring、ibatis、webwork等框架（框架提供的特性和实现的原理） 熟悉分布式、多线程及高性能的设计与编码及性能调优 精通Internet基本协议（TCP/IP,HTTP）内容及相关应用 有大规模高并发访问的Web应用架构设计和开发经验 java面试考纲 —–&gt; 高级JAVA工程师Java基础 Collection和Map 掌握Collection和Map的继承体系 掌握ArrayList、Linkedlist、Vector、Stack、PriorityQueue、HashSet、LinkedHashSet、TreeSet、HashMap、LinedHashMap、TreeMap、WeakHashMap、EnumMap、HashTable的特点和实现原理。 掌握CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap的实现原理和适用场景。 IO 掌握 InputStream、OutputStream、Reader、Writer的继承体系。 掌握字节流(FileInputStream、DataInputStream、BufferedInputStream、FileOutputSteam、DataOutputStream、BufferedOutputStream)和字符流(BufferedReader、InputStreamReader、FileReader、BufferedWriter、OutputStreamWriter、PrintWriter、FileWriter)，并熟练运用。 掌握NIO实现原理及使用方法。 异常 掌握Throwable继承体系。 掌握异常工作原理。 了解常见受检异常(比如FileNotFoundException)、非受检异常(比如NullPointerException)和错误(比如IOError)。 多线程 掌握Executors可以创建的三种(JAVA8增加了一种，共四种)线程池的特点及适用范围。 掌握多线程同步机制，并熟练运用。 Socket 掌握Socket通信原理。 熟练使用多线程结合Socket进行编程。 Java虚拟机 JVM内存区域划分 掌握程序计数器、堆、虚拟机栈、本地方法栈、方法区（JAVA8已移除）、元空间（JAVA8新增）的作用及基本原理。 掌握堆的划分：新生代（Eden、Survivor1、Survivor2）和老年代的作用及工作原理。 掌握JVM内存参数设置及调优。 类加载 掌握类的加载阶段：加载、链接（验证、准备、解析）、初始化、使用、卸载。 掌握类加载器分类及其应用：启动类加载器、扩展类加载器、应用程序类加载器、自定义加载器。 J2EE 掌握JSP内置对象、动作及相关特点和工作原理。 掌握Servlet的特点和工作原理。 掌握Spring框架的IOC和AOP实现原理（反射和动态代理）。 至少掌握一个MVC框架（Spring MVC，Struts等）的工作原理，并熟练运用。 至少掌握一个ORM框架(Hibernate，MyBatis等)的工作原理，并熟练运用。 数据结构与算法 掌握线性表和树的特点并熟练运用。 掌握常用排序和查找算法：插入排序(直接插入排序、希尔排序)、选择排序(直接选择排序、堆排序)、交换排序(冒泡排序、快速排序)、归并排序，顺序查找、二分查找、哈希查找。 熟练运用常见排序和查找算法思想解决编程问题。 了解几大基本算法：贪心算法、分治策略、动态规划。 计算机网络 掌握网络的分层结构，及每层的功能特点。 掌握TCP/IP的通信原理(三次握手、四次挥手) 数据库 掌握复杂的SQL语句编写。 掌握数据库的优化（SQL层面和表设计层面）。 至少掌握一款数据库产品。 熟悉高并发、大数据情况下的数据库开发。 Web技术 掌握AJAX的工作原理。 至少熟悉一款JS框架(比如JQuery)。 设计模式 熟悉常见的设计模式。 会将设计模式理论应用到实际开发中。 Linux 熟练运用Linux常见命令。 熟悉Linux操作系统基本概念及特点。 熟悉Shell脚本。 操作系统 掌握操作系统的进程管理。 了解操作系统的I/O。 正则表达式 掌握常见正则表达式符号。 熟练运用正则表达式解决实际问题(比如匹配电话号码、邮箱、域名等)。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>进阶</tag>
        <tag>架构师</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2013%2F07%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hello world</tag>
      </tags>
  </entry>
</search>